1) Components of the JDK:
The Java Development Kit (JDK) includes the following components:
•	Java Compiler (javac): Converts Java source code into bytecode.
•	Java Runtime Environment (JRE): Provides the runtime environment to execute Java programs. It includes the Java Virtual Machine (JVM) and libraries.
•	Java Debugger (jdb): A tool to debug Java programs.
•	Java Doc (javadoc): Generates documentation from Java source code comments.
•	Java Archive (jar): Helps package Java classes into a single archive.
•	Other tools: Like jconsole, javap, and jps for monitoring, decompiling, and listing Java processes.
2) Differentiate between JDK, JVM, and JRE:
•	JDK (Java Development Kit): Contains everything required to develop and run Java programs, including the JRE, compiler, and development tools.
•	JVM (Java Virtual Machine): Executes the bytecode that Java programs compile to. It abstracts the underlying system architecture to enable platform independence.
•	JRE (Java Runtime Environment): Provides the libraries and JVM necessary to run Java applications. It does not include development tools.
3) Role of the JVM in Java:
The JVM plays a key role in executing Java code by translating Java bytecode into machine-specific instructions. It enables platform independence by executing the same bytecode across different platforms with appropriate JVM implementations.
How the JVM Executes Java Code: The JVM reads bytecode and interprets or compiles it into native machine code using Just-In-Time (JIT) compilation. The process involves class loading, memory management, and garbage collection.
4) Memory Management System of the JVM:
The JVM divides memory into different areas:
•	Heap: Used to store objects and dynamic memory allocation.
•	Stack: Stores method calls, local variables, and references. Each thread has its own stack.
•	Method Area: Stores class-level data, including static variables and metadata.
•	PC Register: Keeps track of the current instruction for each thread.
•	Native Method Stack: Holds native method calls (methods written in languages like C/C++).
Garbage collection automatically frees up memory by removing objects no longer referenced.

5) JIT Compiler and Its Role in the JVM:
The Just-In-Time (JIT) Compiler translates frequently used bytecode into native machine code to improve execution speed. Instead of interpreting the bytecode repeatedly, it compiles it once and runs the native code, speeding up the program.
Bytecode: Intermediate code generated by the Java compiler. It is platform-independent and can be executed by the JVM on any machine. It allows Java to be "write once, run anywhere."
6) Architecture of the JVM:
The architecture of the JVM consists of:
•	Class Loader Subsystem: Loads classes into memory when they are first referenced.
•	Execution Engine: Executes the bytecode either via interpretation or JIT compilation.
•	Runtime Data Areas: Includes the Heap, Stack, Method Area, and other memory structures.
•	Native Method Interface: Enables the JVM to invoke native code written in other languages.
•	Garbage Collector: Automatically manages memory by removing unused objects.

7) How Java Achieves Platform Independence Through the JVM:
Java achieves platform independence by compiling Java code into bytecode, which can be executed by the JVM on any platform. Since the JVM abstracts the underlying operating system and hardware, the same bytecode can be executed on different systems without modification.
8) Significance of the Class Loader in Java:
The Class Loader is responsible for loading classes into the JVM dynamically at runtime. It manages how and when classes are loaded into memory. This system allows classes to be loaded from different sources, including local files, remote locations, and network servers.
Garbage Collection in Java: Java's garbage collection mechanism automatically reclaims memory from objects that are no longer reachable. The JVM manages this by tracking object references and performing cleanup when necessary, typically using algorithms like mark-and-sweep and generational garbage collection.

9) Four Access Modifiers in Java and Their Differences:
•	public: The member or class is accessible from anywhere.
•	private: The member is only accessible within the same class.
•	protected: The member is accessible within the same package and by subclasses.
•	default (package-private): The member is accessible only within the same package. It is the default modifier when no access modifier is specified.



10) Difference Between Public, Protected, and Default Access Modifiers:
•	public: Access from any class.
•	protected: Access within the same package and subclasses, even if they are in different packages.
•	default (package-private): Access within the same package only.
11) Overriding a Method with a Different Access Modifier:
No, you cannot override a method with a stricter access level. For example, you cannot override a protected method with a private method in a subclass. The access level must either be the same or more permissive (e.g., protected to public).
12) Difference Between Protected and Default (Package-Private) Access:
•	protected: Accessible within the same package and by subclasses, even if they are outside the package.
•	default (package-private): Accessible only within the same package, not by subclasses outside the package.
13) Can You Make a Class Private in Java?
Yes, an inner class can be declared as private. This means it can only be accessed from within the enclosing outer class. However, a top-level class cannot be declared as private.
14) Can a Top-Level Class Be Declared as Protected or Private?
No, a top-level class in Java cannot be declared as protected or private. Top-level classes can only have public or default (package-private) access.
15) Accessing a Private Variable or Method from Another Class:
If you declare a variable or method as private in a class, it cannot be accessed from another class, even if that class is in the same package. Private members are strictly confined to the class they are declared in.
16) Concept of Package-Private (Default) Access:
The default (package-private) access level means that the member or class is accessible only within the same package but not from other packages. This allows a certain level of encapsulation without exposing members to the entire application.

